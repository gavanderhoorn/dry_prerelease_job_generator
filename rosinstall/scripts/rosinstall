#!/usr/bin/env python

"""
usage: rosinstall [OPTIONS] INSTALL_PATH [URI]

Options:
-s SETUP_FILE or --setup=SETUP_FILE (use another setup.sh file to create env)
-n or --nobuild (don't perform a 'make core_cools' on the ros stack)

Common invocations:

initial checkout:   rosinstall ~/ros http://ros.org/rosconfigs/all.rosconfig
subsequent update:  rosinstall ~/ros

"""

from __future__ import with_statement

import os
import subprocess
import sys
import xml.dom.minidom #import parse
from optparse import OptionParser
import yaml

import rosinstall.helpers
from rosinstall.vcs import svn, bzr, git

def usage():
  print __doc__ % vars()
  exit(1)

class ROSInstallException(Exception): pass

class Config:
  def __init__(self, config_uri, install_path):
    self.source_uri = config_uri
    self.source = rosinstall.helpers.get_yaml_from_uri(config_uri)
    self.trees = [ ]
    self.base_path = install_path

    if self.source:
      self.load_yaml(self.source)

    

  def load_yaml(self, y):
    for t in y:
      for k, v in t.iteritems():
        if not 'local-name' in v:
          raise ROSInstallException("local-name is required on all code trees")
        else:
          local_name = v['local-name']

        if not 'uri' in v:
          raise ROSInstallException("woah! no uri for svn tree %s" % local_name)
        else:
          source_uri = v['uri']          

        vcs = None
        version = v.get('version', '')
        local_path = os.path.join(self.base_path, local_name)

        #if local_path in self.vcs:
        #  raise Exception("cannot install two things into the same directory!! %s"%local_path)
        
        if k == 'svn':
          vcsc = svn.SVNClient(local_path)
        elif k == 'git':
          vcsc = git.GITClient(local_path)
        elif k == 'bzr':
          vcsc = bzr.BZRClient(local_path)
        else:
          raise ROSInstallException("woah, unknown installation method %s" % k)


        tree = {}
        tree['name'] = local_name
        tree['uri'] = source_uri
        tree['version'] = version
        tree['vcs'] = vcsc
        self.trees.append(tree)

  def ros_path(self):
    for t in self.trees:
      if 'vcs' in t:
        vcsc = t['vcs']
        if rosinstall.helpers.is_path_ros(vcsc.get_path()):
          return vcsc.get_path()
    return None
  
  def write_source(self):
    """
    Write this.rosinstall into the root of the checkout
    """
    if not os.path.exists(self.base_path):
      os.makedirs(self.base_path)
    f = open(os.path.join(self.base_path, "this.rosinstall"), "w+b")
    f.write(yaml.safe_dump(self.source))
    f.close()
    
  def execute_install(self):
    if not os.path.exists(self.base_path):
      os.mkdir(self.base_path)
    for t in self.trees:
      if 'vcs' in t:
        vcsc = t['vcs']
        if not vcsc.path_exists():
          vcsc.checkout(t['uri'], t['version'])
        else:
          if not vcsc.detect_presence():
            raise ROSInstallException("Directory '%s' already exists but is not of type %s"%(vcsc.get_path(), vcsc.get_vcs_type_name()))
          vcsc.update(t['version'])
      else:
        raise ROSInstallException("Failed to install tree '%s'\n vcs not setup correctly")

  # TODO go back and make sure that everything in options.path is described
  # in the yaml, and offer to delete otherwise? not sure, but it could go here



  def get_ros_package_path(self):
    """ Return the simplifed ROS_PACKAGE_PATH """
    code_trees = []
    for t in self.trees:
      if t['name'] != 'ros':
        # take only the first element of the local_name so that we just point to the subdir
        if t['name'].startswith(os.sep):
          code_trees.append(os.path.join(self.base_path, os.sep + t['name'].split(os.sep)[1]))
        else:
          code_trees.append(os.path.join(self.base_path, t['name'].split(os.sep)[0]))        
    rpp = ':'.join(set(code_trees))
    return rpp
    
  
  def generate_include_setup_text(self, filename):
    rpp = self.get_ros_package_path()
    text = ""
    text += "source %s\n" % filename
    text += "export ROS_PACKAGE_PATH=%s:$ROS_PACKAGE_PATH\n" % rpp
    return text

  def generate_full_setup_text(self, ros_root, ros_package_path):
    # overlay or standard
    text = ""
    text += "export ROS_ROOT=%s\n" % ros_root
    text += "export PATH=$ROS_ROOT/bin:$PATH\n" # might include it twice
    text += "export PYTHONPATH=$ROS_ROOT/core/roslib/src:$PYTHONPATH\n"
    text += "if [ ! \"$ROS_MASTER_URI\" ] ; then export ROS_MASTER_URI=http://localhost:11311 ; fi\n"
    text += "export ROS_PACKAGE_PATH=%s\n" % ros_package_path
    text += "source $ROS_ROOT/tools/rosbash/rosbash\n"
    return text
    

  def get_ros_package_path_from_env(self):
    return subprocess.Popen("env | grep ROS_PACKAGE_PATH", stdout=subprocess.PIPE, shell=True, executable="/bin/bash").communicate()[0].split('=')[-1]

  def generate_setup(self, options):
    # simplest case first
    ros_root = self.ros_path()
    rpp = self.get_ros_package_path()

    text = ""
    if options.setup_file:
      if ros_root:
        print >> sys.stderr, "woah. you gave a setup file %s, but your config %s also includes a ROS stack (%s)" % (options.setup_file, self.source_uri, ros_root)
        exit(1)
      # source the file and see if we can grep it, to handle chaining / whatever
      ros_root = rosinstall.helpers.get_ros_root_from_file(options.setup_file)
      if len(ros_root) == 0:
        print >> sys.stderr, "woah. you gave a setup file %s, but that file did not set ROS_ROOT" % options.setup_file
        exit(1)
      text = self.generate_include_setup_text(options.setup_file)
    else:
      if not ros_root: # Must be an overlay if no ros_root options.overlay:
        if not 'ROS_ROOT' in os.environ:
          print >> sys.stderr, "woah. There needs to be a version of ros either in your rosinstall file(%s) or your environment (ROS_ROOT)." % (self.source_uri)
          exit(1)
        ros_root = os.environ['ROS_ROOT']
        existing_rpp = self.get_ros_package_path_from_env()
        if len(existing_rpp) > 0:
          rpp = rpp + ':' + existing_rpp
      text = self.generate_full_setup_text(ros_root, rpp)


    setup_path = os.path.join(options.path, 'setup.sh')
    with open(setup_path, 'w') as f:
      f.write(text)


## legacy for breadcrumb which will be removed shortly.
def installed_uri(path):
  try:
    f = open(os.path.join(path, '.rosinstall_source_uri'),'r')
  except IOError, e:
    pass
    return None
  return rosinstall.helpers.conditional_abspath(f.readline())  # abspath here for backwards compatability with change to abspath in breadcrumb

def rosinstall_main(argv):
  if len(argv) < 2:
    usage()
  args = argv[1:]
  parser = OptionParser(usage="usage: %prog PATH [URI] [options]")
  parser.add_option("-u", "--update", dest="update", default=False,
                    help="(deprecated unused)",
                    action="store_true")
  parser.add_option("-s", "--setup_file", dest="setup_file",
                    metavar="SETUP_FILE",
                    help="create environment using an existing setup file")
  parser.add_option("-o", "--overlay", dest="overlay", default=False,
                    help="(deprecated unused)",
                    action="store_true")
  parser.add_option("-n", "--nobuild", dest="nobuild", default=False,
                    help="skip the build step for the ROS stack",
                    action="store_true")
  parser.add_option("--rosdep-yes", dest="rosdep_yes", default=False,
                    help="Pass through --rosdep-yes to rosmake", 
                    action="store_true")
  (options, args) = parser.parse_args(args)
    

  # Get the path to the rosinstall 
  options.path = os.path.abspath(args[0])

  # Find out what the URI is (args, this.rosinstall, or breadcrumb(for backwards compatability)

  # if two args the 2nd is the config_uri
  if len(args) > 1:
    config_uri = rosinstall.helpers.conditional_abspath(args[1])
  elif os.path.exists(os.path.join(options.path, "this.rosinstall")):
    config_uri = os.path.join(options.path, "this.rosinstall")
  else: ## backwards compatability to be removed in the future
    # try to read the source uri from the breadcrumb mmmm delicious
    config_uri = installed_uri(options.path)
  
  ## Could not get uri therefore error out
  if not config_uri or len(config_uri) == 0:
    parser.error( "update is not possible, since uri could not be determined, looked at args, %s , and %s(deprecated)"%(
        os.path.join(options.path, "this.rosinstall"), os.path.join(options.path, ".rosinstall_source_uri")))

  ## Generate the config class with the uri and path
  config = Config(config_uri, options.path)
  ## Save this.rosinstall 
  config.write_source()
  ## Generate setup.sh and save
  config.generate_setup(options)
  ## install or update each element
  config.execute_install()
  ## bootstrap the build if installing ros
  print config.ros_path()
  if config.ros_path() and not (options.setup_file or options.nobuild):
    if options.rosdep_yes:
      subprocess.check_call("source %s && rosmake rostest --rosdep-install --rosdep-yes" % (os.path.join(options.path, 'setup.sh')), shell=True, executable='/bin/bash')
    else:
      subprocess.check_call("source %s && rosmake rostest --rosdep-install" % (os.path.join(options.path, 'setup.sh')), shell=True, executable='/bin/bash')
  print "\ndone. Now, type 'source %s/setup.sh' to set up your environment.\nAdd that to the bottom of your ~/.bashrc to set it up every time.\n\n" % options.path
  
if __name__ == "__main__":
  try:
    sys.exit(rosinstall_main(sys.argv) or 0)
  except ROSInstallException, e:
    print >> sys.stderr, "ERROR: %s"%str(e)
    sys.exit(1)

