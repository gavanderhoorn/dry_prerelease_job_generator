#!/usr/bin/env python

"""
usage: rosinstall [OPTIONS] INSTALL_PATH [URI]

Options:
-u or --update (URI is optional only when using --update on an existing install)
-s SETUP_FILE or --setup=SETUP_FILE (use another setup.sh file to create env)
-o or --overlay (push current environment into setup.sh)
-n or --nobuild (don't perform a 'make core_cools' on the ros stack)

Common invocations:

initial checkout:   rosinstall ~/ros http://ros.org/rosconfigs/all.rosconfig
subsequent update:  rosinstall -u ~/ros

"""

from __future__ import with_statement
import roslib; roslib.load_manifest("rosinstall")



import os
import subprocess
import sys
import xml.dom.minidom #import parse
from optparse import OptionParser
import yaml

import rosinstall.helpers
from roslib2.vcs import svn, bzr, git

def usage():
  print __doc__ % vars()
  exit(1)

class ROSInstallException(Exception): pass

class Config:
  def __init__(self, config_uri, install_path):
    self.source = rosinstall.helpers.get_yaml_from_uri(config_uri)
    self.trees = [ ]
    self.base_path = install_path

    if self.source:
      self.load_yaml(self.source)

    

  def load_yaml(self, y):
    for t in y:
      for k, v in t.iteritems():
        if not 'local-name' in v:
          raise ROSInstallException("local-name is required on all code trees")
        else:
          local_name = v['local-name']

        if not 'uri' in v:
          raise ROSInstallException("woah! no uri for svn tree %s" % local_name)
        else:
          source_uri = v['uri']          

        vcs = None
        version = v.get('version', '')
        local_path = os.path.join(self.base_path, local_name)

        #if local_path in self.vcs:
        #  raise Exception("cannot install two things into the same directory!! %s"%local_path)
        
        if k == 'svn':
          vcsc = svn.SVNClient(local_path)
        elif k == 'git':
          vcsc = git.GITClient(local_path)
        elif k == 'bzr':
          vcsc = bzr.BZRClient(local_path)
        else:
          raise ROSInstallException("woah, unknown installation method %s" % k)


        tree = {}
        tree['name'] = local_name
        tree['uri'] = source_uri
        tree['version'] = version
        tree['vcs'] = vcsc
        self.trees.append(tree)

  def ros_path(self):
    for t in self.trees:
      if 'vcs' in t:
        vcsc = t['vcs']
        if rosinstall.helpers.is_path_ros(vcsc.get_path()):
          return vcsc.get_path()
    return None
  
  def write_source(self):
    """
    Write this.rosinstall into the root of the checkout
    """
    if not os.path.exists(self.base_path):
      os.makedirs(self.base_path)
    f = open(os.path.join(self.base_path, "this.rosinstall"), "w+b")
    f.write(yaml.safe_dump(self.source))
    f.close()
    
  def execute_install(self):
    if not os.path.exists(self.base_path):
      os.mkdir(self.base_path)
    for t in self.trees:
      if 'vcs' in t:
        vcsc = t['vcs']
        if not vcsc.path_exists():
          vcsc.checkout(t['uri'], t['version'])
        else:
          if not vcsc.detect_presence():
            raise ROSInstallException("Directory '%s' already exists but is not of type %s"%(vcsc.get_path(), vcsc.get_vcs_type_name()))
          vcsc.update(t['version'])
      else:
        raise ROSInstallException("Failed to install tree '%s'\n vcs not setup correctly")

  # TODO go back and make sure that everything in options.path is described
  # in the yaml, and offer to delete otherwise? not sure, but it could go here



  def get_ros_package_path(self):
    """ Return the simplifed ROS_PACKAGE_PATH """
    code_trees = []
    for t in self.trees:
      if t['name'] != 'ros':
        # take only the first element of the local_name so that we just point to the subdir
        if t['name'].startswith(os.sep):
          code_trees.append(os.path.join(self.base_path, os.sep + t['name'].split(os.sep)[1]))
        else:
          code_trees.append(os.path.join(self.base_path, t['name'].split(os.sep)[0]))        
    rpp = ':'.join(set(code_trees))
    return rpp
    
  
  def generate_setup(self, options):
    # simplest case first
    setup_path = os.path.join(options.path, 'setup.sh')
    ros_root = self.ros_path()
    rpp = self.get_ros_package_path()

    text = ""
    if options.setup_file:
      if ros_root:
        print >> sys.stderr, "woah. you gave a setup file %s, but your config %s also includes a ROS stack" % (options.setup_file, options.config_uri)
        exit(1)
      # source the file and see if we can grep it, to handle chaining / whatever
      ros_root = rosinstall.helpers.get_ros_root_from_file(options.setup_file)
      if len(ros_root) == 0:
        print >> sys.stderr, "woah. you gave a setup file %s, but that file did not set ROS_ROOT" % options.setup_file
        exit(1)
      text += "source %s\n" % options.setup_file
      text += "export ROS_PACKAGE_PATH=%s:$ROS_PACKAGE_PATH\n" % rpp
    else:
      if options.overlay:
        if ros_root:
          print >> sys.stderr, "woah. you asked to overlay %s (which contains ROS) on your environment, but your environment already defines ROS_ROOT" % (self.config_uri)
          exit(1)
        if not 'ROS_ROOT' in os.environ:
          print >> sys.stderr, "woah. you asked to overlay %s on your environment, but your environment doesn't have ROS_ROOT set." % (self.config_uri)
          exit(1)
        ros_root = os.environ['ROS_ROOT']
        existing_rpp = subprocess.Popen("env | grep ROS_PACKAGE_PATH", stdout=subprocess.PIPE, shell=True, executable="/bin/bash").communicate()[0].split('=')[-1]
        if len(existing_rpp) > 0:
          rpp = rpp + ':' + existing_rpp
      

      # overlay or standard
      text += "export ROS_ROOT=%s\n" % ros_root
      text += "export PATH=$ROS_ROOT/bin:$PATH\n" # might include it twice
      text += "export PYTHONPATH=$ROS_ROOT/core/roslib/src:$PYTHONPATH\n"
      text += "if [ ! \"$ROS_MASTER_URI\" ] ; then export ROS_MASTER_URI=http://localhost:11311 ; fi\n"
      text += "export ROS_PACKAGE_PATH=%s\n" % rpp
      text += "source $ROS_ROOT/tools/rosbash/rosbash\n"

    with open(setup_path, 'w') as f:
      f.write(text)


## legacy for breadcrumb which will be removed shortly.
def installed_uri(path):
  try:
    f = open(os.path.join(path, '.rosinstall_source_uri'),'r')
  except IOError, e:
    pass
    return None
  return rosinstall.helpers.conditional_abspath(f.readline())  # abspath here for backwards compatability with change to abspath in breadcrumb

def rosinstall_main(argv):
  if len(argv) < 2:
    usage()
  args = argv[1:]
  parser = OptionParser(usage="usage: %prog PATH [URI] [options]")
  parser.add_option("-u", "--update", dest="update", default=False,
                    help="update an existing installation (URI not needed)",
                    action="store_true")
  parser.add_option("-s", "--setup_file", dest="setup_file",
                    metavar="SETUP_FILE",
                    help="create environment using an existing setup file")
  parser.add_option("-o", "--overlay", dest="overlay", default=False,
                    help="use current environment to build setup file",
                    action="store_true")
  parser.add_option("-n", "--nobuild", dest="nobuild", default=False,
                    help="skip the build step for the ROS stack",
                    action="store_true")
  parser.add_option("--rosdep-yes", dest="rosdep_yes", default=False,
                    help="Pass through --rosdep-yes to rosmake", 
                    action="store_true")
  (options, args) = parser.parse_args(args)
  # check for illegal combinations
  if options.overlay and options.setup_file:
    print "\ncan't init from both an overlay and setup file\n\n"
    exit(1)
  if options.update and (options.setup_file or options.overlay):
    print "\ncan't do an update along with init via overlay/setup file\n\n"
    exit(1)
  if len(args) == 0 or (len(args) == 1 and not options.update):
    print "\nneed to specify a URI, unless you're doing an update.\n\n"
    exit(1)
    

  # Get the path to the rosinstall 
  options.path = os.path.abspath(args[0])

  # Find out what the URI is (args, this.rosinstall, or breadcrumb(for backwards compatability)

  # if two args the 2nd is the config_uri
  if len(args) > 1:
    options.config_uri = rosinstall.helpers.conditional_abspath(args[1])
  elif os.path.exists(os.path.join(options.path, "this.rosinstall")):
    options.config_uri = "this.rosinstall"
  else: ## backwards compatability to be removed in the future
    # try to read the source uri from the breadcrumb mmmm delicious
    options.config_uri = installed_uri(options.path)
  
  ## Could not get uri therefore error out
  if not options.config_uri or len(options.config_uri) == 0:
    parser.error( "update is not possible, since uri could not be determined, looked at args, %s , and %s(deprecated)"%(
        os.path.join(options.path, "this.rosinstall"), os.path.join(options.path, ".rosinstall_source_uri")))

  ## Generate the config class with the uri and path
  config = Config(options.config_uri, options.path)
  ## Save this.rosinstall 
  config.write_source()
  ## install or update each element
  config.execute_install()
  ## Generate setup.sh and save
  config.generate_setup(options)
  ## bootstrap the build if installing ros
  if not (options.overlay or options.setup_file or options.nobuild):
    if options.rosdep_yes:
      subprocess.check_call("source %s && rosmake rostest --rosdep-install --rosdep-yes" % (os.path.join(options.path, 'setup.sh')), shell=True, executable='/bin/bash')
    else:
      subprocess.check_call("source %s && rosmake rostest --rosdep-install" % (os.path.join(options.path, 'setup.sh')), shell=True, executable='/bin/bash')
  print "\ndone. Now, type 'source %s/setup.sh' to set up your environment.\nAdd that to the bottom of your ~/.bashrc to set it up every time.\n\n" % options.path
  
if __name__ == "__main__":
  try:
    sys.exit(rosinstall_main(sys.argv) or 0)
  except ROSInstallException, e:
    print >> sys.stderr, "ERROR: %s"%str(e)
    sys.exit(1)

